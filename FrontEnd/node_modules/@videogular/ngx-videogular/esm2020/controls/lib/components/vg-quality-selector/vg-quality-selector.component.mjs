import { Component, ElementRef, Input, ViewEncapsulation, Output, EventEmitter, } from '@angular/core';
import { VgApiService } from '@videogular/ngx-videogular/core';
import * as i0 from "@angular/core";
import * as i1 from "@videogular/ngx-videogular/core";
import * as i2 from "@angular/common";
export class VgQualitySelectorComponent {
    constructor(ref, API) {
        this.API = API;
        this.onBitrateChange = new EventEmitter();
        this.subscriptions = [];
        this.elem = ref.nativeElement;
    }
    ngOnInit() { }
    ngOnChanges(changes) {
        if (changes.bitrates.currentValue && changes.bitrates.currentValue.length) {
            this.bitrates.forEach((item) => (item.label =
                item.label || Math.round(item.bitrate / 1000).toString()));
        }
    }
    selectBitrate(index) {
        this.bitrateSelected = this.bitrates[index];
        this.onBitrateChange.emit(this.bitrates[index]);
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
}
/** @nocollapse */ VgQualitySelectorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: VgQualitySelectorComponent, deps: [{ token: i0.ElementRef }, { token: i1.VgApiService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ VgQualitySelectorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.6", type: VgQualitySelectorComponent, selector: "vg-quality-selector", inputs: { bitrates: "bitrates" }, outputs: { onBitrateChange: "onBitrateChange" }, usesOnChanges: true, ngImport: i0, template: `
    <div class="container">
      <div class="quality-selected" [class.vg-icon-hd]="!bitrateSelected">
        {{ bitrateSelected?.label }}
      </div>
      <select
        class="quality-selector"
        (change)="selectBitrate($event.target.value)"
        tabindex="0"
        aria-label="quality selector"
        [attr.aria-valuetext]="ariaValue"
      >
        <option
          *ngFor="let bitrate of bitrates"
          [value]="bitrate.qualityIndex"
          [selected]="bitrate.qualityIndex === bitrateSelected?.qualityIndex"
        >
          {{ bitrate.label }}
        </option>
      </select>
    </div>
  `, isInline: true, styles: ["vg-quality-selector{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;display:flex;justify-content:center;width:50px;height:50px;cursor:pointer;color:#fff;line-height:50px}vg-quality-selector .container{position:relative;display:flex;flex-grow:1;align-items:center;padding:0;margin:5px}vg-quality-selector select.quality-selector{width:50px;padding:5px 8px;border:none;background:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;color:transparent;font-size:16px}vg-quality-selector select.quality-selector::-ms-expand{display:none}vg-quality-selector select.quality-selector option{color:#000}vg-quality-selector .quality-selected{position:absolute;width:100%;height:50px;top:-6px;text-align:center;text-transform:uppercase;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;padding-top:2px;pointer-events:none}vg-quality-selector .vg-icon-closed_caption:before{width:100%}\n"], dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: VgQualitySelectorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vg-quality-selector', encapsulation: ViewEncapsulation.None, template: `
    <div class="container">
      <div class="quality-selected" [class.vg-icon-hd]="!bitrateSelected">
        {{ bitrateSelected?.label }}
      </div>
      <select
        class="quality-selector"
        (change)="selectBitrate($event.target.value)"
        tabindex="0"
        aria-label="quality selector"
        [attr.aria-valuetext]="ariaValue"
      >
        <option
          *ngFor="let bitrate of bitrates"
          [value]="bitrate.qualityIndex"
          [selected]="bitrate.qualityIndex === bitrateSelected?.qualityIndex"
        >
          {{ bitrate.label }}
        </option>
      </select>
    </div>
  `, styles: ["vg-quality-selector{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;display:flex;justify-content:center;width:50px;height:50px;cursor:pointer;color:#fff;line-height:50px}vg-quality-selector .container{position:relative;display:flex;flex-grow:1;align-items:center;padding:0;margin:5px}vg-quality-selector select.quality-selector{width:50px;padding:5px 8px;border:none;background:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;color:transparent;font-size:16px}vg-quality-selector select.quality-selector::-ms-expand{display:none}vg-quality-selector select.quality-selector option{color:#000}vg-quality-selector .quality-selected{position:absolute;width:100%;height:50px;top:-6px;text-align:center;text-transform:uppercase;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;padding-top:2px;pointer-events:none}vg-quality-selector .vg-icon-closed_caption:before{width:100%}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.VgApiService }]; }, propDecorators: { bitrates: [{
                type: Input
            }], onBitrateChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmctcXVhbGl0eS1zZWxlY3Rvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL25neC12aWRlb2d1bGFyL2NvbnRyb2xzL3NyYy9saWIvY29tcG9uZW50cy92Zy1xdWFsaXR5LXNlbGVjdG9yL3ZnLXF1YWxpdHktc2VsZWN0b3IuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUVWLEtBQUssRUFDTCxpQkFBaUIsRUFJakIsTUFBTSxFQUNOLFlBQVksR0FDYixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsWUFBWSxFQUFrQixNQUFNLGlDQUFpQyxDQUFDOzs7O0FBcUYvRSxNQUFNLE9BQU8sMEJBQTBCO0lBZXJDLFlBQVksR0FBZSxFQUFTLEdBQWlCO1FBQWpCLFFBQUcsR0FBSCxHQUFHLENBQWM7UUFYM0Msb0JBQWUsR0FBaUMsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQU83RSxrQkFBYSxHQUFtQixFQUFFLENBQUM7UUFLakMsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDO0lBQ2hDLENBQUM7SUFFRCxRQUFRLEtBQUksQ0FBQztJQUViLFdBQVcsQ0FBQyxPQUFzQjtRQUNoQyxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRTtZQUN6RSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FDbkIsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUNQLENBQUMsSUFBSSxDQUFDLEtBQUs7Z0JBQ1QsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FDOUQsQ0FBQztTQUNIO0lBQ0gsQ0FBQztJQUVELGFBQWEsQ0FBQyxLQUFhO1FBQ3pCLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFDckQsQ0FBQzs7MElBdENVLDBCQUEwQjs4SEFBMUIsMEJBQTBCLG1LQWhGM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCVDsyRkEyRFUsMEJBQTBCO2tCQW5GdEMsU0FBUzsrQkFDRSxxQkFBcUIsaUJBQ2hCLGlCQUFpQixDQUFDLElBQUksWUFDM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCVDs0SEE2RFEsUUFBUTtzQkFBaEIsS0FBSztnQkFFSSxlQUFlO3NCQUF4QixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBPbkluaXQsXG4gIElucHV0LFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgT25EZXN0cm95LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBPbkNoYW5nZXMsXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgVmdBcGlTZXJ2aWNlLCBCaXRyYXRlT3B0aW9ucyB9IGZyb20gJ0B2aWRlb2d1bGFyL25neC12aWRlb2d1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd2Zy1xdWFsaXR5LXNlbGVjdG9yJyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwicXVhbGl0eS1zZWxlY3RlZFwiIFtjbGFzcy52Zy1pY29uLWhkXT1cIiFiaXRyYXRlU2VsZWN0ZWRcIj5cbiAgICAgICAge3sgYml0cmF0ZVNlbGVjdGVkPy5sYWJlbCB9fVxuICAgICAgPC9kaXY+XG4gICAgICA8c2VsZWN0XG4gICAgICAgIGNsYXNzPVwicXVhbGl0eS1zZWxlY3RvclwiXG4gICAgICAgIChjaGFuZ2UpPVwic2VsZWN0Qml0cmF0ZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIGFyaWEtbGFiZWw9XCJxdWFsaXR5IHNlbGVjdG9yXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZXRleHRdPVwiYXJpYVZhbHVlXCJcbiAgICAgID5cbiAgICAgICAgPG9wdGlvblxuICAgICAgICAgICpuZ0Zvcj1cImxldCBiaXRyYXRlIG9mIGJpdHJhdGVzXCJcbiAgICAgICAgICBbdmFsdWVdPVwiYml0cmF0ZS5xdWFsaXR5SW5kZXhcIlxuICAgICAgICAgIFtzZWxlY3RlZF09XCJiaXRyYXRlLnF1YWxpdHlJbmRleCA9PT0gYml0cmF0ZVNlbGVjdGVkPy5xdWFsaXR5SW5kZXhcIlxuICAgICAgICA+XG4gICAgICAgICAge3sgYml0cmF0ZS5sYWJlbCB9fVxuICAgICAgICA8L29wdGlvbj5cbiAgICAgIDwvc2VsZWN0PlxuICAgIDwvZGl2PlxuICBgLFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgICB2Zy1xdWFsaXR5LXNlbGVjdG9yIHtcbiAgICAgICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiA1MHB4O1xuICAgICAgfVxuICAgICAgdmctcXVhbGl0eS1zZWxlY3RvciAuY29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIG1hcmdpbjogNXB4O1xuICAgICAgfVxuICAgICAgdmctcXVhbGl0eS1zZWxlY3RvciBzZWxlY3QucXVhbGl0eS1zZWxlY3RvciB7XG4gICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICBwYWRkaW5nOiA1cHggOHB4O1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgICAgICAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xuICAgICAgICBhcHBlYXJhbmNlOiBub25lO1xuICAgICAgICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgIH1cbiAgICAgIHZnLXF1YWxpdHktc2VsZWN0b3Igc2VsZWN0LnF1YWxpdHktc2VsZWN0b3I6Oi1tcy1leHBhbmQge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgfVxuICAgICAgdmctcXVhbGl0eS1zZWxlY3RvciBzZWxlY3QucXVhbGl0eS1zZWxlY3RvciBvcHRpb24ge1xuICAgICAgICBjb2xvcjogIzAwMDtcbiAgICAgIH1cbiAgICAgIHZnLXF1YWxpdHktc2VsZWN0b3IgLnF1YWxpdHktc2VsZWN0ZWQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgIHRvcDogLTZweDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgICAgICBmb250LWZhbWlseTogSGVsdmV0aWNhIE5ldWUsIEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XG4gICAgICAgIHBhZGRpbmctdG9wOiAycHg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuICAgICAgdmctcXVhbGl0eS1zZWxlY3RvciAudmctaWNvbi1jbG9zZWRfY2FwdGlvbjpiZWZvcmUge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgIH1cbiAgICBgLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBWZ1F1YWxpdHlTZWxlY3RvckNvbXBvbmVudFxuICBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBASW5wdXQoKSBiaXRyYXRlczogQml0cmF0ZU9wdGlvbnNbXTtcblxuICBAT3V0cHV0KCkgb25CaXRyYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Qml0cmF0ZU9wdGlvbnM+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIGJpdHJhdGVTZWxlY3RlZDogQml0cmF0ZU9wdGlvbnM7XG5cbiAgZWxlbTogSFRNTEVsZW1lbnQ7XG4gIHRhcmdldDogYW55O1xuXG4gIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgYXJpYVZhbHVlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocmVmOiBFbGVtZW50UmVmLCBwdWJsaWMgQVBJOiBWZ0FwaVNlcnZpY2UpIHtcbiAgICB0aGlzLmVsZW0gPSByZWYubmF0aXZlRWxlbWVudDtcbiAgfVxuXG4gIG5nT25Jbml0KCkge31cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKGNoYW5nZXMuYml0cmF0ZXMuY3VycmVudFZhbHVlICYmIGNoYW5nZXMuYml0cmF0ZXMuY3VycmVudFZhbHVlLmxlbmd0aCkge1xuICAgICAgdGhpcy5iaXRyYXRlcy5mb3JFYWNoKFxuICAgICAgICAoaXRlbSkgPT5cbiAgICAgICAgICAoaXRlbS5sYWJlbCA9XG4gICAgICAgICAgICBpdGVtLmxhYmVsIHx8IE1hdGgucm91bmQoaXRlbS5iaXRyYXRlIC8gMTAwMCkudG9TdHJpbmcoKSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc2VsZWN0Qml0cmF0ZShpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5iaXRyYXRlU2VsZWN0ZWQgPSB0aGlzLmJpdHJhdGVzW2luZGV4XTtcbiAgICB0aGlzLm9uQml0cmF0ZUNoYW5nZS5lbWl0KHRoaXMuYml0cmF0ZXNbaW5kZXhdKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzKSA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iXX0=